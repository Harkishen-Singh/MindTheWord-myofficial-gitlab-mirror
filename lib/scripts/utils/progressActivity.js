export class ProgressActivity {

  constructor(parentElementID, svgWidth, svgHeight, outerElementWidth) {
    this.parentElementID = parentElementID;
    this.dataPoints = [];
    this.outerElementWidth = outerElementWidth;
    this.svgWidth = svgWidth;
    this.svgHeight = svgHeight;
    this.upperBound = 300;
    this.container = d3.select(this.parentElementID).append('svg');
    this.dataPoints = null;
    this.xAxisUnit = 300; // for one day
  }

  setDataPoints(dataPoints) {
    this.dataPoints = dataPoints;
    // hard coding for testing
    this.dataPoints = [
      {
        'date': '1',
        'words-translated': '500',
        'words-learnt': '5',
        'saved-translation': '10',
        'websites-visited': '13',
        'quiz': '7'
      },
      {
        'date': '2',
        'words-translated': '700',
        'words-learnt': '7',
        'saved-translation': '17',
        'websites-visited': '11',
        'quiz': '4'
      },
      {
        'date': '3',
        'words-translated': '300',
        'words-learnt': '5',
        'saved-translation': '10',
        'websites-visited': '13',
        'quiz': '7'
      },
      {
        'date': '4',
        'words-translated': '1000',
        'words-learnt': '5',
        'saved-translation': '10',
        'websites-visited': '13',
        'quiz': '7'
      }
    ];
  }

  setScalingY(dataPoints) {
    let max = 0;
    for (let point in dataPoints) {
      max = parseInt(dataPoints[point]['words-translated']) > max ? parseInt(dataPoints[point]['words-translated']) : max;
    }
    max += this.upperBound;
    let wordsPerUnitYScale = max / this.svgHeight,
      xDivisions = this.svgHeight / 10;
    console.log('wordsPerUnitXScale : ' + wordsPerUnitYScale + ' max : '+ max);
    return {
      'xDivisions': xDivisions,
      'wordsPerUnitYScale': wordsPerUnitYScale
    };
  }

  generateCircles(coordinatesList, yScaleDiv) {
    console.log('received generateCirlees as ');
    console.log(coordinatesList);
    let circles = this.container.selectAll('circle').data(coordinatesList).enter().append('circle');
    circles.attr('cx', (d, i) => {
      console.log('i: ' + i + ' d: '+d);
      return d.x_axis * this.xAxisUnit;
    }).attr('cy', d => {
      console.log('y: ' + (this.svgHeight - (d.y_axis/ yScaleDiv)));
      return this.svgHeight - (d.y_axis/ yScaleDiv) ;
    }).attr('r', () => {
      return 5;
    }).attr('fill', () => {
      return 'red';
    }).attr('id', (d, i) => {
      return (this.xAxisUnit * i).toString() + '_node_id';
    });
  }

  generateCurves(coordinatesList, yScaleDiv) {
    let line =  d3.line().curve(d3.curveCardinal).x(function (a,b) {
      return a.x_axis;
    }).y(function (a,b) {
      return a.y_axis;
    });

    let recompute = [];
    for (let inst in coordinatesList) {
      coordinatesList[inst].y_axis = this.svgHeight - (coordinatesList[inst].y_axis / yScaleDiv);
      coordinatesList[inst].x_axis = this.xAxisUnit * coordinatesList[inst].x_axis;
      console.log(coordinatesList[inst].y_axis+ ' ' + coordinatesList[inst].x_axis);
    }

    this.container.append('path').attr('d', line(coordinatesList)).attr('stroke', 'black').attr('stroke-width', '2').attr('fill', 'none');
  }

  generateHovercards(coordinatesList, yScaleDiv) {
    // to be done
  }

  generate() {
    if (document.getElementById(this.parentElementID.substring(1)) !== null) {
      console.warn('found!');
      console.log(document.getElementById('activity-progress-chart'));
      if (this.dataPoints !== null) {
        let scaleDiv = this.setScalingY(this.dataPoints);
        let coordinatesList = [];
      
        for (let coord in this.dataPoints) {
          let instance = {
            'x_axis': coord,
            'y_axis': this.dataPoints[coord]['words-translated']
          };
          coordinatesList.push(instance);
        }
        // graphic patterns are generated by superimposition of components
        this.generateCircles(coordinatesList, scaleDiv.wordsPerUnitYScale);
        this.generateCurves(coordinatesList, scaleDiv.wordsPerUnitYScale);
      } else {
        throw new Error('unable to generate activity progress graph. datapoints not found');
      }  
    } else {
      setTimeout(() => {
        this.generate();
      }, 1000);
    }
    
  }

  assure() {
    console.log('this is working');
  }

  
}